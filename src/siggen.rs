//! A number of signal generators. These are processes with no input (more specifically, their input is `()`).
use crate::{Process};
use std::iter::Once;

/// An `IterSignal` is created from an iterator over `f64`. This exists for two reasons: 
/// 
/// Firstly, a `Process` is a more general purpose `Iterator` with the difference that the
/// next state change takes an input, and our API takes `self` by move rather than by mutable
/// reference, and iteration never fails. 
/// 
/// Secondly, this allows us to create signal generator processes by chaining iterators. For example, 
/// the  [KronikerDelta] generator is contructed from [std::iter::Once<f64>].
/// 
/// `IterSignal` can never fail, so if the iterator its contructed from returns `None` then we 
/// define all future observations to be `0.0`.  
pub struct IterSignal<I>
where I: Iterator<Item = f64> {
    iter: I,
    last: f64
}

impl<I> IterSignal<I> where I: Iterator<Item = f64> {
    pub fn new(it:I) -> Self { Self {iter: it, last: 0.0} }
}

impl<I> Iterator for IterSignal<I>
where I: Iterator<Item = f64> {
    type Item = f64; 
    fn next(&mut self) -> Option<f64> {
        self.iter
            .next()
            .or(Some(0.0))
    }
}

impl<I> Process for IterSignal<I> 
where I: Iterator<Item = f64> {
    type Input = ();
    type Output = f64; 

    fn evolve(self, _:()) -> Self {
        let mut iter = self.iter;
        let last = iter.next().unwrap();
        Self { iter, last }
    }

    fn observe(&self) -> f64 {
        self.last 
    }
}

/// The Kroniker Delta function. It's just an alias for [IterSignal<Once<f64>>]. 
/// 
/// The first sample generated by the KronikerDelta is `1.0`, all subsequent values are `1.0`. 
/// It is also referred to as a "unit impulse."
pub type KronikerDelta = IterSignal<Once<f64>>;
impl Default for KronikerDelta {
    fn default() -> Self {
        IterSignal::new(std::iter::once(1.0))
    }
}

/// A general purpose oscillator, intended for test/analysis purposes. Constructed from
/// a static function pointer, so don't try and make this oscillator stateful. For that 
/// you should define your own processes. 
pub struct Oscillator {
    pub increment: f64, 
    pub phase: f64, 
    f: fn (&Self) -> f64, 
}

impl Process for Oscillator {
    type Input = ();
    type Output = f64; 
    fn evolve(self, _:()) -> Self {
        Self {
            phase: (self.phase + self.increment).fract(), 
            increment: self.increment,
            f: self.f  
        }
    }
    fn observe(&self) -> f64 {
        (self.f)(self)
    }
}

impl Default for Oscillator {
    fn default() -> Self {
        Self {
            increment: 1000.0 / 48000.0, 
            phase: 0.0, 
            f: |osc| 2.0 * osc.phase - 1.0
        }
    }
}

impl Oscillator {
    /// set the oscillator frequency. Resets phase. The frequency needs to be normalized to the 
    /// domain [0, 1] where 1.0 representss the nyquist frequency. 
    pub fn with_frequency(self, freq: f64) -> Self {
        Self {
            phase: 0.0, 
            increment: (freq / 2.0).fract(), 
            f: self.f, 
        }
    }
    
    /// Assign a new mapping
    pub fn with_mapping(self, f: fn(&Self) -> f64) -> Self {
        Self {
            phase: self.phase, 
            increment: self.increment, 
            f
        }
    }

    /// A sine generator 
    pub fn sine() -> Self {
        Self::default()
            .with_mapping(|osc| (2.0 * std::f64::consts::PI * osc.phase).sin())
    }

    /// A pulse train generator
    pub fn pulse_train() -> Self {
        Self::default()
            .with_mapping(|osc|{
                if osc.phase >= osc.increment {
                    0.0
                } else {
                    1.0 
                }
            })
    }
}